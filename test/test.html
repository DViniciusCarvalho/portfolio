<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Desenhador de Árvores Binárias</title>
    
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script>
        const SHELL_OPERATORS = {
            '&': 'Ampersand',
            '&&': 'Double ampersand',
            '|': 'Pipe',
            '||': 'Double Pipe',
            '>': 'Greater-than sign',
            '2>': 'Greater-than sign redirect stderr',
            '>>': 'Double greather-than sign',
            '<': 'Less-than sign',
            '<<': 'Double less-than sign',
            ';': 'Semicolon',
        };

        const SHELL_COMMENT_SIGN = '#';
        const SHELL_VARIABLE_SIGN = '$';

        const SHELL_STRING_QUOTE = '\'';
        const SHELL_STRING_DOUBLE_QUOTE = '\"';

        const RESERVED_WORDS = {
            if: 'IF Conditional Statement',
            then: 'THEN Conditional Statement',
            else: 'ELSE Conditional Statement',
            elif: 'ELIF Conditional Statement',
            fi: 'FI Conditional Statement',
            case: 'CASE Statement',
            esac: 'ESAC Statement',
            for: 'FOR Loop',
            while: 'WHILE Loop',
            until: 'UNTIL Loop',
            do: 'DO Loop',
            done: 'DONE Loop',
            function: 'FUNCTION Declaration',
            select: 'SELECT Loop',
            in: 'IN Keyword',
            return: 'RETURN Statement',
            break: 'BREAK Statement',
            continue: 'CONTINUE Statement',
            exit: 'EXIT Statement',
        };

        const getCommandOptionsArray = (
            commandNode
        ) => {

            const initialNode = commandNode.leftNode;

            const tokensAccumulator = [];

            let nodeAccumulator = initialNode;

            while (true) {
                if (nodeAccumulator.leftNode === null) break;

                tokensAccumulator.push({
                    type: nodeAccumulator.token.type,
                    value: nodeAccumulator.token.value
                });

                nodeAccumulator = nodeAccumulator.leftNode;
            }

            return tokensAccumulator;
        }


        const getCommandArgumentsArray = (
            commandNode
        ) => {

            const initialNode = commandNode.rightNode;

            const tokensAccumulator = [];

            let nodeAccumulator = initialNode;

            while (true) {
                if (nodeAccumulator.rightNode === null) break;

                tokensAccumulator.push({
                    type: nodeAccumulator.token.type,
                    value: nodeAccumulator.token.value
                });

                nodeAccumulator = nodeAccumulator.rightNode;
            }

            return tokensAccumulator;
        }


        const executeSingleCommand = (
            command,
            commandOptions,
            commandArguments,
            stdin = null
        ) => {

            console.log(command.value)
            if (command.value === 'echo') {
                return {
                    stdout: 'foi echo porra',
                    stderr: null,
                    exitStatus: 0
                };
            }

            return {
                stdout: null,
                stderr: null,
                exitStatus: 0
            };
        }


        const executeMultipleCommands = (
            numberOfOperators,
            AST
        ) => {

            const rootNode = AST.root;

            const leftToRightOperators = [
                '&&', 
                '|', 
                '>', 
                '||', 
                ';', 
                '>', 
                '2>', 
                '>>'
            ];

            const rightToLeftOperators = [
                '<', 
                '<<'
            ];

            const commandResultAccumulator = {
                stdout: null,
                stderr: null,
                exitStatus: 0
            }

            const updateCommandResultAccumulator = (value) => {
                const { stdout, stderr, exitStatus } = value;

                commandResultAccumulator.stdout = stdout;
                commandResultAccumulator.stderr = stderr;
                commandResultAccumulator.exitStatus = exitStatus;
            }

            console.log(numberOfOperators);

            for (let i = numberOfOperators; i > 0; i--) {
                let nodeAccumulator = rootNode;
                let previousNodeAccumulator = null;

                for (let k = 1; k < i; k++) {
                    nodeAccumulator = nodeAccumulator.leftNode;

                    if (k === 1) {
                        previousNodeAccumulator = rootNode;
                        continue;
                    }

                    previousNodeAccumulator = previousNodeAccumulator
                                              ? previousNodeAccumulator.leftNode
                                              : null;
                }

     
                const nodeOperator = nodeAccumulator.token.value;
                const previousNodeOperator = previousNodeAccumulator !== null
                                            ? previousNodeAccumulator.token.value
                                            : null;

                const leftNode = nodeAccumulator.leftNode;
                const leftCommandToken = leftNode.token;
                const leftCommandOptions = leftNode.leftNode? getCommandOptionsArray(leftNode) : [];
                const leftCommandArguments = leftNode.rightNode? getCommandArgumentsArray(leftNode) : [];

                const rightNode = nodeAccumulator.rightNode;
                const rightCommandToken = rightNode.token;
                const rightCommandOptions = rightNode.leftNode? getCommandOptionsArray(rightNode) : [];
                const rightCommandArguments = rightNode.rightNode? getCommandArgumentsArray(rightNode) : [];

                const isStartOperatorNode = i === numberOfOperators;
                const isLeftToRightOperator = leftToRightOperators.indexOf(nodeOperator) !== -1;

                const leftCommandHasRedirectStderrToSameAsStdoutSign = leftCommandArguments.filter(arg => 
                    arg.value === '2>&1'
                ).length !== 0;

                const rightCommandHasRedirectStderrToSameAsStdoutSign = rightCommandArguments.filter(arg =>
                    arg.value === '2>&1'
                ).length !== 0;


                if (isLeftToRightOperator) {
                    const leftCommandResult = isStartOperatorNode
                                            ? executeSingleCommand(
                                                    leftCommandToken,
                                                    leftCommandOptions,
                                                    leftCommandArguments
                                                )
                                            : commandResultAccumulator;

                    
                    const leftCommandWasSuccessfullyExecuted = leftCommandResult.exitStatus === 0;

                    const operatorsThatOmitOutput = [
                        '|', 
                        '>', 
                        '>>', 
                        '2>'
                    ];

                    const isNotOperatorThatOmitOutput = operatorsThatOmitOutput.indexOf(
                        nodeOperator
                    ) === -1;

                    const previousOperatorIsRightToLeft = rightToLeftOperators.indexOf(
                        previousNodeOperator
                    ) !== -1;


                    if (isNotOperatorThatOmitOutput && isStartOperatorNode) {
                        const preLeftCommandStdout = leftCommandResult.stdout !== null
                                                        ? `\n${leftCommandResult.stdout}`
                                                        : '';
                        console.log(preLeftCommandStdout)

                        const stdout = commandResultAccumulator.stdout !== null 
                                        ? `${commandResultAccumulator.stdout}${preLeftCommandStdout}`
                                        : leftCommandResult.stdout;

                        const preLeftCommandStderr = leftCommandResult.stderr !== null
                                                        ? `\n${leftCommandResult.stderr}`
                                                        : '';

                        const stderr = commandResultAccumulator.stderr !== null
                                        ? `${commandResultAccumulator.stderr}${preLeftCommandStderr}`
                                        : leftCommandResult.stderr;

                        updateCommandResultAccumulator({
                            stdout: stdout,
                            stderr: stderr,
                            exitStatus: leftCommandResult.exitStatus
                        });
                    }

                    if (previousOperatorIsRightToLeft) {
                        previousNodeAccumulator?.insertLeft(rightNode);
                        continue;
                    }

                    if (nodeOperator === '&&' && leftCommandWasSuccessfullyExecuted) {
                        const rightCommandResult = executeSingleCommand(
                            rightCommandToken,
                            rightCommandOptions,
                            rightCommandArguments
                        );
                        
                        const preRightCommandStdout = rightCommandResult.stdout !== null
                                                        ? `\n${rightCommandResult.stdout}`
                                                        : '';

                        const stdout = commandResultAccumulator.stdout !== null 
                                        ? `${commandResultAccumulator.stdout}${preRightCommandStdout}`
                                        : rightCommandResult.stdout;

                        const preRightCommandStderr = rightCommandResult.stderr !== null
                                                        ? `\n${rightCommandResult.stderr}`
                                                        : '';

                        const stderr = commandResultAccumulator.stderr !== null
                                        ? `${commandResultAccumulator.stderr}${preRightCommandStderr}`
                                        : rightCommandResult.stderr;

                        updateCommandResultAccumulator({
                            stdout: stdout,
                            stderr: stderr,
                            exitStatus: rightCommandResult.exitStatus
                        });
                    }
                    else if (nodeOperator === '|') {
                        const rightCommandStdin = `${leftCommandResult.stdout}\n${leftCommandResult.stderr}`;
            
                        const rightCommandResult = executeSingleCommand(
                            rightCommandToken,
                            rightCommandOptions,
                            rightCommandArguments,
                            leftCommandHasRedirectStderrToSameAsStdoutSign
                            ? rightCommandStdin 
                            : leftCommandResult.stdout
                        );
            
                        const stdout = commandResultAccumulator.stdout;

                        const preRightCommandStderr = rightCommandResult.stderr !== null
                                                        ? `\n${rightCommandResult.stderr}`
                                                        : '';

                        const stderr = commandResultAccumulator.stderr !== null
                                        ? `${commandResultAccumulator.stderr}${preRightCommandStderr}`
                                        : rightCommandResult.stderr;
                                
                        updateCommandResultAccumulator({
                            stdout: stdout,
                            stderr: stderr,
                            exitStatus: rightCommandResult.exitStatus
                        });
                    }  
                    else if (nodeOperator === '||' && !leftCommandWasSuccessfullyExecuted) {
                        const rightCommandResult = executeSingleCommand(
                            rightCommandToken,
                            rightCommandOptions,
                            rightCommandArguments
                        );

                        const preRightCommandStdout = rightCommandResult.stdout !== null
                                                        ? `\n${rightCommandResult.stdout}`
                                                        : '';

                        const stdout = commandResultAccumulator.stdout !== null 
                                        ? `${commandResultAccumulator.stdout}${preRightCommandStdout}`
                                        : rightCommandResult.stdout;

                        const preRightCommandStderr = rightCommandResult.stderr !== null
                                                        ? `\n${rightCommandResult.stderr}`
                                                        : '';

                        const stderr = commandResultAccumulator.stderr !== null
                                        ? `${commandResultAccumulator.stderr}${preRightCommandStderr}`
                                        : rightCommandResult.stderr;

                        updateCommandResultAccumulator({
                            stdout: stdout,
                            stderr: stderr,
                            exitStatus: rightCommandResult.exitStatus
                        });
                    }  
                    else if (nodeOperator === '>') {
                        const rightCommandStdin = `${leftCommandResult.stdout}\n${leftCommandResult.stderr}`;

                        const rightCommandResult = executeSingleCommand(
                            rightCommandToken,
                            rightCommandOptions,
                            rightCommandArguments,
                            rightCommandHasRedirectStderrToSameAsStdoutSign
                            ? rightCommandStdin
                            : leftCommandResult.stdout
                        );

                        updateCommandResultAccumulator({
                            stdout: commandResultAccumulator.stdout,
                            stderr: commandResultAccumulator.stderr,
                            exitStatus: rightCommandResult.exitStatus
                        });
                    }  
                    else if (nodeOperator === '>>') {
                        const rightCommandStdin = `${leftCommandResult.stdout}\n${leftCommandResult.stderr}`;

                        const rightCommandResult = executeSingleCommand(
                            rightCommandToken,
                            rightCommandOptions,
                            rightCommandArguments,
                            rightCommandHasRedirectStderrToSameAsStdoutSign
                            ? rightCommandStdin
                            : leftCommandResult.stdout
                        );

                        updateCommandResultAccumulator({
                            stdout: commandResultAccumulator.stdout,
                            stderr: commandResultAccumulator.stderr,
                            exitStatus: rightCommandResult.exitStatus
                        });
                    }  
                    else if (nodeOperator === '2>') {
                        const rightCommandResult = executeSingleCommand(
                            rightCommandToken,
                            rightCommandOptions,
                            rightCommandArguments,
                            leftCommandResult.stderr
                        );

                        updateCommandResultAccumulator({
                            stdout: commandResultAccumulator.stdout,
                            stderr: commandResultAccumulator.stderr,
                            exitStatus: rightCommandResult.exitStatus
                        });
                    }  
                    else if (nodeOperator === ';') {
                        const rightCommandResult = executeSingleCommand(
                            rightCommandToken,
                            rightCommandOptions,
                            rightCommandArguments
                        );

                        const preRightCommandStdout = rightCommandResult.stdout !== null
                                                        ? `\n${rightCommandResult.stdout}`
                                                        : '';

                        const stdout = commandResultAccumulator.stdout !== null 
                                        ? `${commandResultAccumulator.stdout}${preRightCommandStdout}`
                                        : rightCommandResult.stdout;

                        const preRightCommandStderr = rightCommandResult.stderr !== null
                                                        ? `\n${rightCommandResult.stderr}`
                                                        : '';

                        const stderr = commandResultAccumulator.stderr !== null
                                        ? `${commandResultAccumulator.stderr}${preRightCommandStderr}`
                                        : rightCommandResult.stderr;

                        updateCommandResultAccumulator({
                            stdout: stdout,
                            stderr: stderr,
                            exitStatus: rightCommandResult.exitStatus
                        });
                    }

                }
                else {
                    console.log(`entrei qnd era ${nodeOperator}`)
                    const rightCommandResult = executeSingleCommand(
                        rightCommandToken,
                        rightCommandOptions,
                        rightCommandArguments
                    );

                    const leftCommandStdin = `${rightCommandResult.stdout}\n${rightCommandResult.stderr}`;

                    const leftCommandResult = executeSingleCommand(
                        leftCommandToken,
                        leftCommandOptions,
                        leftCommandArguments,
                        leftCommandStdin
                    );

                    const preLeftCommandStdout = leftCommandResult.stdout !== null
                                                 ? `\n${leftCommandResult.stdout}`
                                                 : '';

                    const stdout = commandResultAccumulator.stdout !== null 
                                   ? `${commandResultAccumulator.stdout}${preLeftCommandStdout}`
                                   : leftCommandResult.stdout;

                    const preLeftCommandStderr = leftCommandResult.stderr !== null
                                                 ? `\n${leftCommandResult.stderr}`
                                                 : '';

                    const stderr = commandResultAccumulator.stderr !== null
                                   ? `${commandResultAccumulator.stderr}${preLeftCommandStderr}`
                                   : leftCommandResult.stderr;

                    updateCommandResultAccumulator({
                        stdout: stdout,
                        stderr: stderr,
                        exitStatus: leftCommandResult.exitStatus
                    });
                }
                console.log(nodeOperator, commandResultAccumulator)
            }


            return commandResultAccumulator;
        }


        const getNumberOfOperators = (
            AST
        ) => {

            const initialNode = AST.root;

            let operatorsNumber = 0;
            let nodeAccumulator = initialNode;

            while (true) {
                if (nodeAccumulator.leftNode === null) break;

                if (nodeAccumulator.token.value in SHELL_OPERATORS) operatorsNumber++;

                nodeAccumulator = nodeAccumulator.leftNode;
            }

            return operatorsNumber;
        }


        const getNodeToStartAnalyzing = (
            node,
            lastOperatorNodeFind = null
        ) => {

            if (node.leftNode === null) return lastOperatorNodeFind;

            lastOperatorNodeFind = node.token.value in SHELL_OPERATORS? node : lastOperatorNodeFind;

            return getNodeToStartAnalyzing(node.leftNode, lastOperatorNodeFind);

        }


        const executeAST = (
            AST
        ) => {

            const numberOfOperators = getNumberOfOperators(AST);
            const syntaxTreeIsSingleCommand = numberOfOperators === 0;

            if (syntaxTreeIsSingleCommand) {
                const commandNode = AST.root;

                const { commandContext, ...tokenWithoutContext } = commandNode.token;

                const command = tokenWithoutContext;
                const commandOptions = commandNode.leftNode? getCommandOptionsArray(commandNode) : [];
                const commandArguments = commandNode.rightNode? getCommandArgumentsArray(commandNode) : [];

                return executeSingleCommand(
                    command, 
                    commandOptions,
                    commandArguments
                );
            }

            return executeMultipleCommands(
                numberOfOperators,
                AST
            );
        }

        class ParseTreeError {
            constructor(errorMessage, errorStatus) {}
        }

        class ExecutionTreeError {
            constructor(errorMessage, errorStatus) {}
        }

        const splitCommand = (
            command
        ) => {

            const parts = [];
        
            let currentWord = '';
            let insideString = false;
            let isSingleQuote = false;
            let isDoubleQuote = false;

            for (let i = 0; i < command.length; i++) {
                const char = command[i];

                const isSingleQuoteStringStart = char === '\'' && !insideString;
                const isSingleQuoteStringEnd = char === '\'' && insideString && isSingleQuote;

                const isDoubleQuoteStringStart = char === '"' && !insideString;
                const isDoubleQuoteStringEnd = char === '"' && insideString && isDoubleQuote;

                const isSpace = char === ' ';

                const isTheLastChar = i + 1 === command.length;


                if (isSingleQuoteStringStart) {
                    insideString = true;
                    isSingleQuote = true;
                    currentWord += char;
                    continue;
                }
                else if (isDoubleQuoteStringStart) {
                    insideString = true;
                    isDoubleQuote = true;
                    currentWord += char;
                    continue;
                }
                else if (isSingleQuoteStringEnd) {
                    insideString = false;
                    isSingleQuote = false;
                    currentWord += char;
                    parts.push(currentWord);
                    currentWord = '';
                }
                else if (isDoubleQuoteStringEnd) {
                    insideString = false;
                    isDoubleQuote = false;
                    currentWord += char;
                    parts.push(currentWord);
                    currentWord = '';
                }
                else if (isSpace) {
                    if (insideString) {
                        currentWord += char;
                        continue;
                    }
                    else {
                        parts.push(currentWord);
                        currentWord = '';
                    }
                }
                else {
                    currentWord += char;
                    if (isTheLastChar) parts.push(currentWord);
                }
            }
        
            return parts.filter(part => part !== '');

        }


        const lexer = (
            command
        ) => {

            const splittedCommand = splitCommand(command);

            const tokens = splittedCommand.reduce((
                acc, 
                current
            ) => {

                const token = {
                    type: 'String',
                    value: current
                };

                const startsWithSingleQuote = current.startsWith(SHELL_STRING_QUOTE);
                const startsWithDoubleQuote = current.startsWith(SHELL_STRING_DOUBLE_QUOTE);

                const isOperator = current in SHELL_OPERATORS;
                const isStderrRedirect = current === '2>';
                const isComment = current.startsWith(SHELL_COMMENT_SIGN);
                const isReservedWord = current in RESERVED_WORDS;
                const isVariable = current.startsWith(SHELL_VARIABLE_SIGN);
                const isString = startsWithSingleQuote || startsWithDoubleQuote;
                const isNumber = !isNaN(Number(current));


                if (isOperator) {
                    token['type'] = SHELL_OPERATORS[current];
                    token['value'] = current;
                }
                else if (isStderrRedirect) {
                    token['type'] = 'Stderr redirect';
                    token['value'] = current;
                }
                else if (isComment) {
                    token['type'] = 'Comment';
                    token['value'] = current;
                }
                else if (isReservedWord) {
                    token['type'] = RESERVED_WORDS[current];
                    token['value'] = current;
                }
                else if (isVariable) {
                    token['type'] = 'Variable';
                    token['value'] = current;
                }
                else if (isString) {
                    token['type'] = 'String';
                    token['value'] = current;
                }
                else if (isNumber) {
                    token['type'] = 'Number';
                    token['value'] = current;
                }

                acc.push(token);

                return acc;

            }, []);

            return tokens;

        }

        const doCommandTree = (
            commandAndArgumentsSlice
        ) => {

            const commandIndex = 0;
            const commandParametersSliceStartIndex = commandIndex + 1;

            const commandToken = commandAndArgumentsSlice[0];

            const commandParameterTokensSlice = commandAndArgumentsSlice.slice(
                commandParametersSliceStartIndex
            );

            const commandNode = new ParseTreeNode(commandToken);

            const optionNodes = [];
            const argumentNodes = [];

            commandParameterTokensSlice.forEach(commandParameterToken => {
                const lastOption = optionNodes.length - 1;
                const lastArgument = argumentNodes.length - 1;

                const tokenValue = commandParameterToken.value;
                const tokenValueIsOption = tokenValue.startsWith('-');


                if (tokenValueIsOption) {
                    const optionNode = new ParseTreeNode(commandParameterToken);

                    if (lastOption >= 0) {
                        optionNodes[lastOption].insertLeft(optionNode);
                    }

                    optionNodes.push(optionNode);
                }
                else {
                    const argumentNode = new ParseTreeNode(commandParameterToken);

                    if (lastArgument >= 0) {
                        argumentNodes[lastArgument].insertRight(argumentNode);
                    }

                    argumentNodes.push(argumentNode);
                }
            });


            if (optionNodes.length) {
                commandNode.insertLeft(optionNodes[0]);
            }

            if (argumentNodes.length) {
                commandNode.insertRight(argumentNodes[0]);
            }

            return commandNode;

        }


        const doOperationTree = (
            tokens
        ) => {

            const nodes = [];
            const tokensAccumulator = [];

            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                const isOperator = token.value in SHELL_OPERATORS;
                const isTheLastToken = i + 1 === tokens.length;
                
                if (!isOperator) tokensAccumulator.push(token);

                if (isOperator || isTheLastToken) {
                    if (tokensAccumulator.length) {
                        const commandNodeTree = doCommandTree(tokensAccumulator);
                        nodes.push(commandNodeTree);
                    }
                }

                if (isOperator) {
                    const operatorNode = new ParseTreeNode(token);

                    nodes.push(operatorNode);
                    tokensAccumulator.length = 0;

                    continue;
                }

            }

            const shellOperators = nodes.filter(node => node.token.value in SHELL_OPERATORS);

            const firstOperatorIndex = nodes.indexOf(shellOperators[0]);
            const lastOperatorIndex = nodes.lastIndexOf(shellOperators[shellOperators.length - 1]);


            let lastOperatorIndexAccumulator = 0;

            for (let i = 0; i < nodes.length; i++) {
                const isOperator = nodes[i].token.value in SHELL_OPERATORS;
                const isTheFirstOperator = i === firstOperatorIndex;
                const hasTokenBefore = !!nodes[i - 1];
                const hasTokenAfter = !!nodes[i + 1];

                if (isOperator) {
                    if (isTheFirstOperator) {
                        if (hasTokenBefore) nodes[i].insertLeft(nodes[i - 1]);
                        if (hasTokenAfter) nodes[i].insertRight(nodes[i + 1]);

                    }
                    else {
                        nodes[i].insertLeft(nodes[lastOperatorIndexAccumulator]);

                        if (hasTokenAfter) nodes[i].insertRight(nodes[i + 1]);
                    }

                    lastOperatorIndexAccumulator = i;
                }

            }

            return shellOperators.length? nodes[lastOperatorIndex] : nodes[nodes.length - 1];

        }


        const parser = (
            tokens
        ) => {

            const reservedWordsToken = tokens.filter(token => token.value in RESERVED_WORDS);
            const shellOperatorsToken = tokens.filter(token => token.value in SHELL_OPERATORS);

            const reservedWords = reservedWordsToken.map(token => token.value);
            const shellOperators = shellOperatorsToken.map(token => token.value);
            

            if (reservedWords.length) {
                const mergedReservedWords = reservedWords.join(',');

                return new ParseTreeError(
                    `${mergedReservedWords}: syntax error, reserved words are not yet accepted in this shell interpreter`,
                    2
                );
            }

            if (shellOperators.indexOf('&') !== -1) {
                return new ParseTreeError(
                    '&: syntax error, ampersand operator is not yet accepted in this shell interpreter',
                    2
                );
            }


            const isNotSingleCommand = shellOperatorsToken.length;
            const lastOperator = shellOperatorsToken.pop();
            
            const rootNode = isNotSingleCommand 
                            ? new ParseTreeNode(lastOperator)
                            : doCommandTree(tokens);
        
            if (isNotSingleCommand) {
                const rootNodeToken = lastOperator;
                const rootNodeIndex = tokens.lastIndexOf(rootNodeToken);
                const lastCommandTokenIndex = rootNodeIndex + 1;

                const lastCommandSlice = tokens.slice(lastCommandTokenIndex);
                const otherSlice = tokens.slice(0, rootNodeIndex);
                const lastCommandNodeTree = doCommandTree(lastCommandSlice);

                const leftRootNode = doOperationTree(otherSlice);

                rootNode.insertRight(lastCommandNodeTree);
                rootNode.insertLeft(leftRootNode);
            }

            const parseTree = new ParseTree(rootNode);
            
            console.log(parseTree)
            parseTree.draw()

            return parseTree;
        }

        class ParseTree {    
            constructor(root) {
                this.root = root;
            }

            insertRootRight(node) {
                this.root.insertRight(node);
            }

            insertRootLeft(node) {
                this.root.insertLeft(node);
            }

            drawTree(x, y, node) {
                const spacing = 50;
                const circleRadius = 30;
                fill(255);
                noStroke();
                ellipse(x, y, circleRadius * 2, circleRadius * 2);
                fill(0);
                textAlign(CENTER, CENTER);
                text(node.token.value, x, y);

                if (node.leftNode) {
                    stroke(0);
                    line(x, y, x - spacing, y + spacing);
                    this.drawTree(x - spacing, y + spacing, node.leftNode);
                }

                if (node.rightNode) {
                    stroke(0);
                    line(x, y, x + spacing, y + spacing);
                    this.drawTree(x + spacing, y + spacing, node.rightNode);
                }
            }

            draw() {
                if (this.root) {
                    const canvasWidth = 800;
                    createCanvas(canvasWidth, canvasWidth);
                    background(255);
                    this.drawTree(canvasWidth / 2, 50, this.root);
                }
            }
        }

        class ParseTreeNode {
            constructor(
                token,
                rightNode = null, 
                leftNode = null
            ) {
                this.token = token;
                this.rightNode = rightNode;
                this.leftNode = leftNode;
            }

            insertRight(node) {
                this.rightNode = node;
            }

            insertLeft(node) {
                this.leftNode = node;
            }
        }

        const interpretCommand = (
            command
        ) => {

            console.log(command)
            const commandTokens = lexer(command);
            const abstractSyntaxTree = parser(commandTokens);

            if (abstractSyntaxTree instanceof ParseTreeError) {
                return {
                    stdout: null,
                    stderr: abstractSyntaxTree.errorMessage,
                    exitStatus: abstractSyntaxTree.errorStatus
                };
            }

            const result = executeAST(abstractSyntaxTree);

            return result;
        }


        function setup() {
            console.log('aq')
            const result = interpretCommand('echo && tome pai && echo');
            console.log(result)
        }
    </script>
</body>
</html>