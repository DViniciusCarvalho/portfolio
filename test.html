<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Desenhador de Árvores Binárias</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>
<body>
    <script>
        const SHELL_OPERATORS = {
            '&': 'Ampersand',
            '&&': 'Double ampersand',
            '|': 'Pipe',
            '||': 'Double Pipe',
            '>': 'Greater-than sign',
            '2>': 'Greater-than sign redirect stderr',
            '>>': 'Double greather-than sign',
            '<': 'Less-than sign',
            '<<': 'Double less-than sign',
            ';': 'Semicolon',
        };

        const SHELL_COMMENT_SIGN = '#';
        const SHELL_VARIABLE_SIGN = '$';

        const SHELL_STRING_QUOTE = '\'';
        const SHELL_STRING_DOUBLE_QUOTE = '\"';

        const RESERVED_WORDS = {
            if: 'IF Conditional Statement',
            then: 'THEN Conditional Statement',
            else: 'ELSE Conditional Statement',
            elif: 'ELIF Conditional Statement',
            fi: 'FI Conditional Statement',
            case: 'CASE Statement',
            esac: 'ESAC Statement',
            for: 'FOR Loop',
            while: 'WHILE Loop',
            until: 'UNTIL Loop',
            do: 'DO Loop',
            done: 'DONE Loop',
            function: 'FUNCTION Declaration',
            select: 'SELECT Loop',
            in: 'IN Keyword',
            return: 'RETURN Statement',
            break: 'BREAK Statement',
            continue: 'CONTINUE Statement',
            exit: 'EXIT Statement',
        };

        class ParseTree {    
            constructor(root) {
                this.root = root;
            }

            insertRootRight(node) {
                this.root.insertRight(node);
            }

            insertRootLeft(node) {
                this.root.insertLeft(node);
            }

            drawTree(x, y, node) {
                const spacing = 50;
                const circleRadius = 30;
                fill(255);
                noStroke();
                ellipse(x, y, circleRadius * 2, circleRadius * 2);
                fill(0);
                textAlign(CENTER, CENTER);
                text(node.token.value, x, y);

                if (node.leftNode) {
                    stroke(0);
                    line(x, y, x - spacing, y + spacing);
                    this.drawTree(x - spacing, y + spacing, node.leftNode);
                }

                if (node.rightNode) {
                    stroke(0);
                    line(x, y, x + spacing, y + spacing);
                    this.drawTree(x + spacing, y + spacing, node.rightNode);
                }
            }

            draw() {
                if (this.root) {
                    const canvasWidth = 800;
                    createCanvas(canvasWidth, canvasWidth);
                    background(255);
                    this.drawTree(canvasWidth / 2, 50, this.root);
                }
            }
        }

        class ParseTreeNode {
            constructor(
                token,
                rightNode = null, 
                leftNode = null
            ) {
                this.token = token;
                this.rightNode = rightNode;
                this.leftNode = leftNode;
            }

            insertRight(node) {
                this.rightNode = node;
            }

            insertLeft(node) {
                this.leftNode = node;
            }
        }


        const splitCommand = (
            command
        ) => {

            const parts = [];
        
            let currentWord = '';
            let insideString = false;

            let isSingleQuote = false;
            let isDoubleQuote = false;

            for (let i = 0; i < command.length; i++) {
                const char = command[i];

                const isSingleQuoteStringStart = char === '\'' && !insideString;
                const isSingleQuoteStringEnd = char === '\'' && insideString && isSingleQuote;

                const isDoubleQuoteStringStart = char === '"' && !insideString;
                const isDoubleQuoteStringEnd = char === '"' && insideString && isDoubleQuote;

                const isSpace = char === ' ';

                const isTheLastChar = i + 1 === command.length;


                if (isSingleQuoteStringStart) {
                    insideString = true;
                    isSingleQuote = true;
                    currentWord += char;
                    continue;
                }
                else if (isDoubleQuoteStringStart) {
                    insideString = true;
                    isDoubleQuote = true;
                    currentWord += char;
                    continue;
                }
                else if (isSingleQuoteStringEnd) {
                    insideString = false;
                    isSingleQuote = false;
                    currentWord += char;
                    parts.push(currentWord);
                    currentWord = '';
                }
                else if (isDoubleQuoteStringEnd) {
                    insideString = false;
                    isDoubleQuote = false;
                    currentWord += char;
                    parts.push(currentWord);
                    currentWord = '';
                }
                else if (isSpace) {
                    if (insideString) {
                        currentWord += char;
                        continue;
                    }
                    else {
                        parts.push(currentWord);
                        currentWord = '';
                    }
                }
                else {
                    currentWord += char;
                    if (isTheLastChar) parts.push(currentWord);
                }
            }
        
            return parts.filter(part => part !== '');

        }


        const lexer = (command) => {
            const splittedCommand = splitCommand(command);

            const tokens = splittedCommand.reduce((
                acc, 
                current
            ) => {

                const token = {};

                if (current in SHELL_OPERATORS) {
                    token['type'] = SHELL_OPERATORS[current];
                    token['value'] = current;
                }
                else if (current.startsWith(SHELL_COMMENT_SIGN)) {
                    token['type'] = 'Comment';
                    token['value'] = current;
                }
                else if (current in RESERVED_WORDS) {
                    token['type'] = RESERVED_WORDS[current];
                    token['value'] = current;
                }
                else if (current.startsWith(SHELL_VARIABLE_SIGN)) {
                    token['type'] = 'Variable';
                    token['value'] = current;
                }
                else if (
                    current.startsWith(SHELL_STRING_QUOTE) || current.startsWith(SHELL_STRING_DOUBLE_QUOTE)
                ) {
                    token['type'] = 'String';
                    token['value'] = current;
                }
                else if (!isNaN(Number(current))) {
                    token['type'] = 'Number';
                    token['value'] = current;
                }
                else {
                    token['type'] = 'String';
                    token['value'] = current;
                }

                acc.push(token);

                return acc;

            }, []);

            return tokens;

        }


        const doCommandTree = (
            commandAndArgumentsSlice
        ) => {

            const commandIndex = 0;
            const commandParametersSliceStartIndex = commandIndex + 1;

            const commandToken = commandAndArgumentsSlice[0];

            const commandParameterTokensSlice = commandAndArgumentsSlice.slice(
                commandParametersSliceStartIndex
            );

            const commandNode = new ParseTreeNode({ 
                commandContext: 'Command',
                ...commandToken
            });


            const optionNodes = [];
            const argumentNodes = [];

            commandParameterTokensSlice.forEach(commandParameterToken => {
                const lastOption = optionNodes.length - 1;
                const lastArgument = argumentNodes.length - 1;

                const tokenValue = commandParameterToken.value;
                const tokenValueIsOption = tokenValue.startsWith('-');


                if (tokenValueIsOption) {
                    const optionNode = new ParseTreeNode({
                        commandContext: 'Option',
                        ...commandParameterToken
                    });

                    if (lastOption >= 0) {
                        optionNodes[lastOption].insertLeft(optionNode);
                    }

                    optionNodes.push(optionNode);
                }
                else {
                    const argumentNode = new ParseTreeNode({
                        commandContext: 'Argument',
                        ...commandParameterToken
                    });

                    if (lastArgument >= 0) {
                        argumentNodes[lastArgument].insertRight(argumentNode);
                    }

                    argumentNodes.push(argumentNode);
                }
            });


            if (optionNodes.length) {
                commandNode.insertLeft(optionNodes[0]);
            }

            if (argumentNodes.length) {
                commandNode.insertRight(argumentNodes[0]);
            }

            return commandNode;

        }


        const doOperationTree = (
            tokens
        ) => {

            const nodes = [];
            const tokensAccumulator = [];

            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                const isOperator = token.value in SHELL_OPERATORS;
                const isTheLastToken = i + 1 === tokens.length;
                
                if (!isOperator) tokensAccumulator.push(token);

                if (isOperator || isTheLastToken) {
                    if (tokensAccumulator.length) {
                        const commandNodeTree = doCommandTree(tokensAccumulator);
                        nodes.push(commandNodeTree);
                    }
                }

                if (isOperator) {
                    const operatorNode = new ParseTreeNode({
                        commandContext: 'Operator',
                        ...token
                    });

                    nodes.push(operatorNode);
                    tokensAccumulator.length = 0;

                    continue;
                }

            }

            const shellOperators = nodes.filter(node => node.token.value in SHELL_OPERATORS);

            const firstOperatorIndex = nodes.indexOf(shellOperators[0]);
            const lastOperatorIndex = nodes.lastIndexOf(shellOperators[shellOperators.length - 1]);


            let lastOperatorIndexAccumulator = 0;

            for (let i = 0; i < nodes.length; i++) {
                const isOperator = nodes[i].token.value in SHELL_OPERATORS;
                const isTheFirstOperator = i === firstOperatorIndex;
                const hasTokenBefore = !!nodes[i - 1];
                const hasTokenAfter = !!nodes[i + 1];

                if (isOperator) {
                    if (isTheFirstOperator) {
                        if (hasTokenBefore) nodes[i].insertLeft(nodes[i - 1]);
                        if (hasTokenAfter) nodes[i].insertRight(nodes[i + 1]);

                    }
                    else {
                        nodes[i].insertLeft(nodes[lastOperatorIndexAccumulator]);

                        if (hasTokenAfter) nodes[i].insertRight(nodes[i + 1]);
                    }

                    lastOperatorIndexAccumulator = i;
                }

            }

            return shellOperators.length? nodes[lastOperatorIndex] : nodes[nodes.length - 1];

        }


        const parser = (
            tokens
        ) => {

            const reservedWordTokens = tokens.filter(token => token.value in RESERVED_WORDS);

            if (reservedWordTokens.length) {
                return new ParseTreeError('reserved words are not yet accepted.');
            }

            const shellOperatorsInOrder = tokens.filter(token => token.value in SHELL_OPERATORS);

            const isNotSingleCommand = shellOperatorsInOrder.length;

            const lastOperator = shellOperatorsInOrder.pop();

            const rootNode = isNotSingleCommand 
                            ? new ParseTreeNode({ commandContext: 'Operator', ...lastOperator })
                            : doCommandTree(tokens);
        

            if (isNotSingleCommand) {
                const rootNodeToken = lastOperator;
                const rootNodeIndex = tokens.lastIndexOf(rootNodeToken);
                const lastCommandTokenIndex = rootNodeIndex + 1;

                const lastCommandSlice = tokens.slice(lastCommandTokenIndex);
                const otherSlice = tokens.slice(0, rootNodeIndex);
                const lastCommandNodeTree = doCommandTree(lastCommandSlice);

                const leftRootNode = doOperationTree(otherSlice);

                rootNode.insertRight(lastCommandNodeTree);
                rootNode.insertLeft(leftRootNode);
            }

            const parseTree = new ParseTree(rootNode);

            parseTree.draw()
            
            return parseTree;
        }

        const executeCommand = (
            command,
            commandOptions,
            commandArguments
        ) => {

            return {
                stdout: null,
                stderr: null,
                exitStatus: 0
            };
        }


        const getCommandOptionsAndArguments = () => {

        }


        const isSingleCommand = (
            AST
        ) => {

            const initialNode = AST.root;

            let operatorsNumber = 0;
            let nodeAccumulator = initialNode;

            while (true) {
                if (nodeAccumulator.leftNode === null) break;

                if (nodeAccumulator.token.value in SHELL_OPERATORS) operatorsNumber++;

                nodeAccumulator = nodeAccumulator.leftNode;
            }

            return operatorsNumber === 0;
        }


        const getCommandOptionsArray = (
            commandNode
        ) => {

            const initialNode = commandNode.leftNode;

            const tokensAccumulator = [];

            let nodeAccumulator = initialNode;

            while (true) {
                if (nodeAccumulator.leftNode === null) break;

                tokensAccumulator.push({
                    type: nodeAccumulator.token.type,
                    value: nodeAccumulator.token.value
                });

                nodeAccumulator = nodeAccumulator.leftNode;
            }

            return tokensAccumulator;
        }


        const getCommandArgumentsArray = (
            commandNode
        ) => {

            const initialNode = commandNode.rightNode;

            const tokensAccumulator = [];

            let nodeAccumulator = initialNode;

            while (true) {
                if (nodeAccumulator.rightNode === null) break;

                tokensAccumulator.push({
                    type: nodeAccumulator.token.type,
                    value: nodeAccumulator.token.value
                });

                nodeAccumulator = nodeAccumulator.rightNode;
            }

            return tokensAccumulator;
        }


        const getNodeToStartAnalyzing = (
            node,
            lastOperatorNodeFind = null
        ) => {

            if (node.leftNode === null) return lastOperatorNodeFind;

            lastOperatorNodeFind = node.token.value in SHELL_OPERATORS? node : lastOperatorNodeFind;

            return getNodeToStartAnalyzing(node.leftNode, lastOperatorNodeFind);

        }


        const analyzeAST = (
            AST
        ) => {

            const syntaxTreeIsSingleCommand = isSingleCommand(AST);

            if (syntaxTreeIsSingleCommand) {
                const commandNode = AST.root;

                const { commandContext, ...tokenWithoutContext } = commandNode.token;

                const command = tokenWithoutContext;
                const commandOptions = commandNode.leftNode? getCommandOptionsArray(commandNode) : [];
                const commandArguments = commandNode.rightNode? getCommandArgumentsArray(commandNode) : [];

                console.log(command);
                console.log(commandOptions);
                console.log(commandArguments);

                return executeCommand(
                    command, 
                    commandOptions,
                    commandArguments
                );
            }
            // else {

            // }
            // const commandStartNode = getNodeToStartAnalyzing(AST.root);

            return {
                stdout: null,
                stderr: null,
                exitStatus: 0
            };
        }

        function setup() {
            const lexed = lexer('echo -a -b -c -d -e -f kkkk 2 3 4 porra \'se foda menor\'')
            const tree = parser(lexed)
            console.log(analyzeAST(tree))
        }

    </script>
</body>
</html>